<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Stop Safari from zooming the whole page; let PDF.js handle zoom -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>TurboSign</title>
  <style>
    :root { color-scheme: dark light; }
    html,body { margin:0; height:100%; background:#0b0c10;
      /* Reduce browser over-scroll artifacts on mobile */
      overscroll-behavior: contain;
      /* Allow taps without double-tap zoom */
      touch-action: manipulation;
    }
    /* iOS-friendly full-height */
    #viewer { border:0; width:100%; height:100dvh; background:#121418; display:block; }

    /* Phones only (≤768px) — bottom toolbar */
    @media (max-width:768px){
      .ts-bar{
        position:fixed; left:0; right:0; bottom:0; z-index:9999;
        display:flex; gap:10px; justify-content:space-between; align-items:center;
        padding:10px 12px calc(10px + env(safe-area-inset-bottom));
        background:rgba(15,17,21,.92); backdrop-filter:saturate(1.2) blur(6px);
        border-top:1px solid #20242c; font:14px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      }
      .ts-btn{
        flex:1 1 auto; min-width:44px; min-height:48px;
        display:flex; flex-direction:column; align-items:center; justify-content:center;
        gap:6px; padding:8px 6px; border-radius:10px; border:1px solid #2a2f39; color:#e8eaed; background:#1a1d24;
      }
      .ts-btn:active{ transform:translateY(1px); }
      .ts-btn svg{ width:22px; height:22px; display:block }
      .ts-file{ display:none }
      /* keep viewer content above dock */
      body { padding-bottom: calc(76px + env(safe-area-inset-bottom)); }
    }

    /* Fallback Text overlay */
    .ts-text {
      position:absolute; left:0; top:0;
      color:#111; background:transparent; font:16px/1.25 -apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      pointer-events:auto; user-select:text; white-space:pre-wrap;
      min-width:80px; min-height:24px;
      outline:2px solid #4da3ff; outline-offset:2px;
    }
    .ts-text[contenteditable="true"] { cursor:text; }
    .ts-text-handle { position:absolute; right:-10px; bottom:-10px; width:18px; height:18px; border-radius:50%; background:#4da3ff; }

    /* Fallback Ink canvas overlays */
    .ts-ink {
      position:absolute; inset:0; pointer-events:auto; touch-action:none; /* block page scroll while drawing */
    }
  </style>
</head>
<body>
  <!-- Stock PDF.js Default UI (ESM build: /web + /build *.mjs) -->
  <iframe id="viewer" src="/web/viewer.html#zoom=page-width" allow="clipboard-read; clipboard-write"></iframe>

  <!-- Phone toolbar -->
  <div class="ts-bar" id="tsBar" aria-label="TurboSign mobile toolbar">
    <button class="ts-btn" id="tsOpen" title="Open">
      <svg viewBox="0 0 24 24" fill="none"><path d="M3 7h5l2 2h11v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M3 7V5a2 2 0 0 1 2-2h4l2 2h6" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Open</span>
    </button>
    <button class="ts-btn" id="tsFind" title="Find">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="6.5" stroke="currentColor" stroke-width="1.6"/><path d="M20 20l-3.5-3.5" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Find</span>
    </button>
    <button class="ts-btn" id="tsZoomOut" title="Zoom out">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="7.5" stroke="currentColor" stroke-width="1.6"/><path d="M8 11h6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/><path d="M20 20l-3-3" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>−</span>
    </button>
    <button class="ts-btn" id="tsZoomIn" title="Zoom in">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="7.5" stroke="currentColor" stroke-width="1.6"/><path d="M11 8v6M8 11h6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>+</span>
    </button>
    <button class="ts-btn" id="tsInk" title="Ink">
      <svg viewBox="0 0 24 24" fill="none"><path d="M3 21l6-2 9.5-9.5a2.1 2.1 0 0 0-3-3L6 16l-3 5z" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Ink</span>
    </button>
    <button class="ts-btn" id="tsText" title="Text">
      <svg viewBox="0 0 24 24" fill="none"><path d="M4 6h16M12 6v12M7 18h10" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>Text</span>
    </button>
    <button class="ts-btn" id="tsSave" title="Save">
      <svg viewBox="0 0 24 24" fill="none"><path d="M5 7h9l5 5v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M8 7V4h6v3" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Save</span>
    </button>
    <input id="tsFile" class="ts-file" type="file" accept="application/pdf">
  </div>

  <script>
    // Block Safari page pinch/double-tap zoom; PDF zoom stays inside viewer
    ['gesturestart','gesturechange','gestureend','dblclick'].forEach(type=>{
      window.addEventListener(type, e=>{ e.preventDefault(); }, { passive:false });
    });

    // Optional: register SW for offline if you ship /sw.js
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('/sw.js').catch(console.error);

    // iOS Safari dynamic viewport
    const viewerEl = document.getElementById('viewer');
    const fitDvh = () => viewerEl && (viewerEl.style.height = Math.max(window.innerHeight, screen.height * 0.6) + 'px');
    addEventListener('orientationchange', fitDvh, {passive:true});
    addEventListener('resize', fitDvh, {passive:true});
    fitDvh();

    (function(){
      const frame = document.getElementById('viewer');
      if (!frame) return;

      let lastObjectURL = null;
      const inkCanvases = new Map(); // pageNumber -> {canvas, ctx, dirty}

      function waitForApp(){
        return new Promise(resolve=>{
          const poll=()=>{ try{
            const a = frame.contentWindow?.PDFViewerApplication;
            if (a?.initializedPromise) return a.initializedPromise.then(()=>resolve(a));
          }catch{} setTimeout(poll,50); };
          poll();
        });
      }

      function clickInViewer(id){
        try{ const el = frame.contentDocument?.getElementById(id); if (el) { el.click(); return true; } }catch{}
        return false;
      }

      async function loadPdfLib(){
        if (window.PDFLib) return true;
        const local = '/vendor/pdf-lib.min.js';
        let ok = await new Promise(res=>{ const s=document.createElement('script'); s.src=local; s.onload=()=>res(true); s.onerror=()=>res(false); document.body.appendChild(s); });
        if (ok) return true;
        ok = await new Promise(res=>{ const s=document.createElement('script'); s.src='https://unpkg.com/pdf-lib/dist/pdf-lib.min.js'; s.onload=()=>res(true); s.onerror=()=>res(false); document.body.appendChild(s); });
        return ok;
      }

      // OPEN (local) + revoke ObjectURL after load
      document.getElementById('tsOpen').onclick = ()=> document.getElementById('tsFile').click();
      document.getElementById('tsFile').onchange = (e)=>{
        const f = e.target.files && e.target.files[0]; if (!f) return;
        if (lastObjectURL) { URL.revokeObjectURL(lastObjectURL); lastObjectURL = null; }
        lastObjectURL = URL.createObjectURL(f);
        frame.src = `/web/viewer.html?file=${encodeURIComponent(lastObjectURL)}#zoom=page-width`;
        waitForApp().then(app => {
          app.eventBus?.on?.('documentloaded', ()=>{
            if (lastObjectURL) { URL.revokeObjectURL(lastObjectURL); lastObjectURL = null; }
            detectEditors(app);
          });
        });
      };

      // FIND (focus input so iOS keyboard appears)
      document.getElementById('tsFind').onclick = async ()=>{
        const app = await waitForApp();
        try { app.findBar?.open?.(); } catch {}
        try { frame.contentDocument?.getElementById('findInput')?.focus(); } catch {}
      };

      // ZOOM − / +
      document.getElementById('tsZoomOut').onclick = async ()=>{
        const app = await waitForApp(); const v = app.pdfViewer;
        v.currentScale = +Math.max(0.1, v.currentScale / 1.1).toFixed(3);
      };
      document.getElementById('tsZoomIn').onclick = async ()=>{
        const app = await waitForApp(); const v = app.pdfViewer;
        v.currentScale = +Math.min(5, v.currentScale * 1.1).toFixed(3);
      };

      // INK: try built-in editor; else fallback overlay
      document.getElementById('tsInk').onclick = async ()=>{
        const app = await waitForApp();
        if (clickInViewer('editorInk')) return;
        if (app?.pdfViewer?.annotationEditorUIManager?.updateMode) {
          app.pdfViewer.annotationEditorUIManager.updateMode('ink'); return;
        }
        enableInkFallback(app);
      };

      // TEXT: try built-in editor; else fallback
      document.getElementById('tsText').onclick = async ()=>{
        const app = await waitForApp();
        if (clickInViewer('editorFreeText')) return;
        if (app?.pdfViewer?.annotationEditorUIManager?.updateMode) {
          app.pdfViewer.annotationEditorUIManager.updateMode('freetext'); return;
        }
        enableTextFallback(app);
      };

      // SAVE: flatten fallback Ink/Text and download/open
      document.getElementById('tsSave').onclick = async () => {
        const app = await waitForApp();
        if (!app?.pdfDocument) { alert('Open a PDF first.'); return; }
        const ok = await loadPdfLib(); if (!ok) { alert('Save failed: pdf-lib unavailable.'); return; }

        const raw = await app.pdfDocument.getData();
        const pdfDoc = await window.PDFLib.PDFDocument.load(raw);

        // Flatten fallback Ink
        for (const [pageNum, obj] of inkCanvases) {
          if (!obj?.dirty) continue;
          const pv = app.pdfViewer.getPageView(pageNum-1);
          const vp = pv.viewport;
          const dpr = obj.dpr || window.devicePixelRatio || 1;
          const widthPts  = obj.canvas.width  / dpr / vp.scale;
          const heightPts = obj.canvas.height / dpr / vp.scale;
          const png = await pdfDoc.embedPng(obj.canvas.toDataURL('image/png'));
          const page = pdfDoc.getPage(pageNum-1);
          // full-page overlay: put at (0,0)
          page.drawImage(png, { x: 0, y: 0, width: widthPts, height: heightPts });
        }

        // Flatten fallback Text
        const boxes = Array.from(frame.contentDocument.querySelectorAll('.ts-text'));
        for (const box of boxes) {
          const pageDiv = box.closest('.page'); if (!pageDiv) continue;
          const pageNum = +pageDiv.getAttribute('data-page-number');
          const pv = app.pdfViewer.getPageView(pageNum-1);
          const vp = pv.viewport;
          const pr = pageDiv.getBoundingClientRect();
          const br = box.getBoundingClientRect();
          const leftPx = br.left - pr.left, topPx = br.top - pr.top;
          const widthPx = br.width, heightPx = br.height;
          const widthPts  = widthPx / vp.scale;
          const heightPts = heightPx / vp.scale;
          const xPts = leftPx / vp.scale;
          const yPts = vp.height - ((topPx + heightPts) / vp.scale);
          const page = pdfDoc.getPage(pageNum-1);
          const text = box.textContent || '';
          page.drawText(text, {
            x: xPts, y: yPts + 4,
            size: Math.max(8, Math.min(24, 12 / vp.scale)),
            color: window.PDFLib.rgb(0,0,0),
            maxWidth: widthPts,
            lineHeight: 1.25
          });
        }

        const out = await pdfDoc.save();
        const blob  = new Blob([out], { type:'application/pdf' });
        const appName = (app._docFilename || app.baseUrl || 'document.pdf').toString();
        const fname = appName.split('/').pop().split('#')[0].split('?')[0] || 'document.pdf';
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const url = URL.createObjectURL(blob);
        if (isIOS) {
          window.open(url, '_blank'); setTimeout(()=>URL.revokeObjectURL(url), 15000);
        } else {
          const a = document.createElement('a'); a.href = url; a.download = fname;
          document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        }
      };

      // --- Helpers ---

      function detectEditors(app){
        try {
          const hasUI = !!app?.pdfViewer?.annotationEditorUIManager;
          const dom = frame.contentDocument;
          const hasInkId  = !!dom?.getElementById('editorInk');
          const hasTextId = !!dom?.getElementById('editorFreeText');
          if (!hasUI && !hasInkId)  document.getElementById('tsInk').style.display  = 'none';
          if (!hasUI && !hasTextId) document.getElementById('tsText').style.display = 'none';
        } catch {}
      }

      // Fallback Ink: overlay a full-size canvas per page, clamp to page, block page scroll while drawing
      function enableInkFallback(app){
        const doc = frame.contentDocument;
        const container = doc.getElementById('viewer');
        if (!container) return;

        // Ensure each page has a canvas overlay
        const pages = Array.from(container.querySelectorAll('.page'));
        for (const pageDiv of pages) {
          pageDiv.style.position = 'relative';
          const pageNum = +pageDiv.getAttribute('data-page-number');
          if (inkCanvases.has(pageNum)) continue;

          const c = doc.createElement('canvas'); c.className='ts-ink'; pageDiv.appendChild(c);
          const r = pageDiv.getBoundingClientRect();
          const dpr = Math.max(window.devicePixelRatio || 1, 1);
          c.width = Math.round(r.width * dpr); c.height = Math.round(r.height * dpr);
          c.style.width = r.width + 'px'; c.style.height = r.height + 'px';
          const ctx = c.getContext('2d'); ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#111'; ctx.lineWidth = 2.5 * dpr;
          inkCanvases.set(pageNum, { canvas:c, ctx, dpr, dirty:false });

          // Resize with zoom
          app.eventBus?.on?.('scalechanging', ({scale})=>{
            const rr = pageDiv.getBoundingClientRect();
            c.width = Math.round(rr.width * dpr); c.height = Math.round(rr.height * dpr);
            c.style.width = rr.width + 'px'; c.style.height = rr.height + 'px';
            // NOTE: we keep drawn pixels as-is (scale with canvas); adequate for signatures/markups
          });

          // Pointer drawing (works on Safari/Chrome/Edge/Firefox)
          let drawing=false, lx=0, ly=0;
          c.addEventListener('pointerdown', e=>{ drawing=true; c.setPointerCapture(e.pointerId);
            const rect=c.getBoundingClientRect(); lx=(e.clientX-rect.left)*dpr; ly=(e.clientY-rect.top)*dpr;
            e.preventDefault();
          }, {passive:false});
          c.addEventListener('pointermove', e=>{ if(!drawing) return; const rect=c.getBoundingClientRect();
            const x=(e.clientX-rect.left)*dpr, y=(e.clientY-rect.top)*dpr;
            ctx.beginPath(); ctx.moveTo(lx,ly); ctx.lineTo(x,y); ctx.stroke();
            lx=x; ly=y; inkCanvases.get(pageNum).dirty=true;
          }, {passive:true});
          c.addEventListener('pointerup',   e=>{ drawing=false; try{c.releasePointerCapture(e.pointerId);}catch{} }, {passive:true});
          c.addEventListener('pointercancel', ()=>{ drawing=false; }, {passive:true});
        }

        alert('Ink: draw directly on pages. (Built-in editor not found, using fallback.)');
      }

      // Fallback Text: tap to place, drag/resize, clamp to page
      function enableTextFallback(app){
        const doc = frame.contentDocument;
        const container = doc.getElementById('viewer'); if (!container) return;

        const onClick = (ev) => {
          const pageDiv = ev.target.closest('.page'); if (!pageDiv) return;
          const rect = pageDiv.getBoundingClientRect();
          const x = ev.clientX - rect.left, y = ev.clientY - rect.top;

          const box = doc.createElement('div'); box.className='ts-text'; box.contentEditable='true';
          box.textContent = 'Type…';
          pageDiv.style.position='relative'; pageDiv.appendChild(box);
          box.style.left = Math.max(4, Math.min(x - 40, rect.width - 84)) + 'px';
          box.style.top  = Math.max(4, Math.min(y - 12, rect.height - 24)) + 'px';
          box.focus();

          // Drag within bounds
          let dragging=false,sx=0,sy=0,bl=0,bt=0;
          box.addEventListener('pointerdown', (e)=>{ if (e.target === box) {
            dragging=true; box.setPointerCapture(e.pointerId); sx=e.clientX; sy=e.clientY; bl=parseFloat(box.style.left)||0; bt=parseFloat(box.style.top)||0; e.preventDefault();
          }}, {passive:false});
          box.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy; let L=bl+dx, T=bt+dy;
            const pr=pageDiv.getBoundingClientRect(); const br=box.getBoundingClientRect();
            L=Math.max(0,Math.min(L, pr.width - br.width)); T=Math.max(0,Math.min(T, pr.height - br.height));
            box.style.left=L+'px'; box.style.top=T+'px';
          });
          box.addEventListener('pointerup', (e)=>{ dragging=false; try{box.releasePointerCapture(e.pointerId);}catch{} });

          // Resize
          const handle = doc.createElement('div'); handle.className='ts-text-handle'; box.appendChild(handle);
          let resizing=false, rsx=0, rsy=0, baseW=0, baseH=0;
          handle.addEventListener('pointerdown',(e)=>{ e.stopPropagation(); resizing=true; handle.setPointerCapture(e.pointerId); rsx=e.clientX; rsy=e.clientY; baseW=box.offsetWidth; baseH=box.offsetHeight; });
          handle.addEventListener('pointermove',(e)=>{ if(!resizing) return; const dx=e.clientX-rsx, dy=e.clientY-rsy; box.style.width=(baseW+dx)+'px'; box.style.height=(baseH+dy)+'px'; });
          handle.addEventListener('pointerup',(e)=>{ resizing=false; try{handle.releasePointerCapture(e.pointerId);}catch{} });

          // Delete when empty
          box.addEventListener('keydown',(e)=>{ if((e.key==='Backspace'||e.key==='Delete') && box.textContent.trim()===''){ box.remove(); } });

          container.removeEventListener('click', onClick, true);
        };

        container.addEventListener('click', onClick, true);
        alert('Text: tap a page to place. Drag to move, resize with the dot, backspace to remove.');
      }

      // Run editor detection on init (covers built-in editors)
      waitForApp().then(detectEditors);
    })();
  </script>
</body>
</html>