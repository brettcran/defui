<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>TurboSign</title>
  <style>
    :root { color-scheme: dark light; }
    html,body { margin:0; height:100%; background:#0b0c10; }
    /* iOS-friendly full-height */
    #viewer { border:0; width:100%; height:100dvh; background:#121418; display:block; }

    /* Phones only (≤768px) — TurboSign bottom toolbar */
    @media (max-width:768px){
      .ts-bar{
        position:fixed; left:0; right:0; bottom:0; z-index:9999;
        display:flex; gap:10px; justify-content:space-between; align-items:center;
        padding:10px 12px calc(10px + env(safe-area-inset-bottom));
        background:rgba(15,17,21,.92); backdrop-filter:saturate(1.2) blur(6px);
        border-top:1px solid #20242c; font:14px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      }
      .ts-btn{
        flex:1 1 auto; min-width:44px; min-height:48px;
        display:flex; flex-direction:column; align-items:center; justify-content:center;
        gap:6px; padding:8px 6px; border-radius:10px; border:1px solid #2a2f39; color:#e8eaed; background:#1a1d24;
      }
      .ts-btn:active{ transform:translateY(1px); }
      .ts-btn svg{ width:22px; height:22px; display:block }
      .ts-file{ display:none }
      /* keep viewer content above dock */
      body { padding-bottom: calc(76px + env(safe-area-inset-bottom)); }
    }
  </style>
</head>
<body>
  <!-- Stock PDF.js Default UI (ESM build: /web + /build *.mjs) -->
  <iframe id="viewer" src="/web/viewer.html#zoom=page-width" allow="clipboard-read; clipboard-write"></iframe>

  <!-- Phone toolbar (no Thumbs) -->
  <div class="ts-bar" id="tsBar" aria-label="TurboSign mobile toolbar">
    <button class="ts-btn" id="tsOpen" title="Open">
      <svg viewBox="0 0 24 24" fill="none"><path d="M3 7h5l2 2h11v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M3 7V5a2 2 0 0 1 2-2h4l2 2h6" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Open</span>
    </button>
    <button class="ts-btn" id="tsFind" title="Find">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="6.5" stroke="currentColor" stroke-width="1.6"/><path d="M20 20l-3.5-3.5" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Find</span>
    </button>
    <button class="ts-btn" id="tsZoomOut" title="Zoom out">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="7.5" stroke="currentColor" stroke-width="1.6"/><path d="M8 11h6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/><path d="M20 20l-3-3" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>−</span>
    </button>
    <button class="ts-btn" id="tsZoomIn" title="Zoom in">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="7.5" stroke="currentColor" stroke-width="1.6"/><path d="M11 8v6M8 11h6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>+</span>
    </button>
    <button class="ts-btn" id="tsInk" title="Ink">
      <svg viewBox="0 0 24 24" fill="none"><path d="M3 21l6-2 9.5-9.5a2.1 2.1 0 0 0-3-3L6 16l-3 5z" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Ink</span>
    </button>
    <button class="ts-btn" id="tsText" title="Text">
      <svg viewBox="0 0 24 24" fill="none"><path d="M4 6h16M12 6v12M7 18h10" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>Text</span>
    </button>
    <button class="ts-btn" id="tsSave" title="Save">
      <svg viewBox="0 0 24 24" fill="none"><path d="M5 7h9l5 5v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M8 7V4h6v3" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Save</span>
    </button>
    <input id="tsFile" class="ts-file" type="file" accept="application/pdf">
  </div>

  <script>
    // Optional: register SW for offline if you ship /sw.js (it can precache *.mjs fine)
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').catch(console.error);
    }

    // iOS Safari: keep 100dvh sane on rotate/address bar changes
    const viewerEl = document.getElementById('viewer');
    const fitDvh = () => viewerEl && (viewerEl.style.height = Math.max(window.innerHeight, screen.height * 0.6) + 'px');
    addEventListener('orientationchange', fitDvh, {passive:true});
    addEventListener('resize', fitDvh, {passive:true});
    fitDvh();

    (function(){
      const frame = document.getElementById('viewer');
      if (!frame) return;

      let lastObjectURL = null;

      // Wait for the ESM viewer to finish initializing
      function waitForApp(){
        return new Promise(resolve=>{
          const poll=()=>{ try{
            const a = frame.contentWindow?.PDFViewerApplication;
            if (a?.initializedPromise) return a.initializedPromise.then(()=>resolve(a));
          }catch{} setTimeout(poll,50); };
          poll();
        });
      }

      // Convenience: try clicking a built-in control by id (if present)
      function clickInViewer(id){
        try{
          const d = frame.contentDocument;
          const el = d && d.getElementById(id);
          if (el) { el.click(); return true; }
        }catch{}
        return false;
      }

      // OPEN (local file) + revoke previous ObjectURL after load
      document.getElementById('tsOpen').onclick = ()=> document.getElementById('tsFile').click();
      document.getElementById('tsFile').onchange = (e)=>{
        const f = e.target.files && e.target.files[0]; if (!f) return;
        if (lastObjectURL) { URL.revokeObjectURL(lastObjectURL); lastObjectURL = null; }
        lastObjectURL = URL.createObjectURL(f);
        frame.src = `/web/viewer.html?file=${encodeURIComponent(lastObjectURL)}#zoom=page-width`;
        waitForApp().then(app => app.eventBus?.on?.('documentloaded', ()=> {
          if (lastObjectURL) { URL.revokeObjectURL(lastObjectURL); lastObjectURL = null; }
          // run feature detection once a real doc is open
          detectAndToggleEditorButtons(app);
        }));
      };

      // FIND (focus the input to pop iOS keyboard)
      document.getElementById('tsFind').onclick = async ()=>{
        const app = await waitForApp();
        try { app.findBar?.open?.(); } catch {}
        try { const d = frame.contentDocument; d.getElementById('findInput')?.focus(); } catch {}
      };

      // ZOOM − / + (clamped & smooth)
      document.getElementById('tsZoomOut').onclick = async ()=>{
        const app = await waitForApp();
        const v = app.pdfViewer; const target = Math.max(0.1, v.currentScale / 1.1);
        v.currentScale = +target.toFixed(3);
      };
      document.getElementById('tsZoomIn').onclick = async ()=>{
        const app = await waitForApp();
        const v = app.pdfViewer; const target = Math.min(5, v.currentScale * 1.1);
        v.currentScale = +target.toFixed(3);
      };

      // INK: use built-in if the editor exists; otherwise hide button
      document.getElementById('tsInk').onclick = async ()=>{
        const app = await waitForApp();
        if (clickInViewer('editorInk')) return;
        if (app?.pdfViewer?.annotationEditorUIManager?.updateMode) {
          app.pdfViewer.annotationEditorUIManager.updateMode('ink'); return;
        }
        alert('Ink is not available in this PDF.js build.');
      };

      // TEXT: use built-in if the editor exists; otherwise hide button
      document.getElementById('tsText').onclick = async ()=>{
        const app = await waitForApp();
        if (clickInViewer('editorFreeText')) return;
        if (app?.pdfViewer?.annotationEditorUIManager?.updateMode) {
          app.pdfViewer.annotationEditorUIManager.updateMode('freetext'); return;
        }
        alert('Text is not available in this PDF.js build.');
      };

      // SAVE (robust; no dependency on hidden #download)
      document.getElementById('tsSave').onclick = async () => {
        const app = await waitForApp();
        if (!app?.pdfDocument) { alert('Open a PDF first.'); return; }

        try {
          // Always get bytes from the ESM API
          const bytes = await app.pdfDocument.getData(); // Uint8Array
          const blob  = new Blob([bytes], { type:'application/pdf' });
          const fname = (app._docFilename || app.baseUrl || 'document.pdf')
                          .toString().split('/').pop().split('#')[0].split('?')[0] || 'document.pdf';

          // iOS Safari ignores download attr: open a tab, user saves via Share
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                        (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
          const url = URL.createObjectURL(blob);
          if (isIOS) {
            window.open(url, '_blank');
            setTimeout(()=>URL.revokeObjectURL(url), 15000);
          } else {
            const a = document.createElement('a');
            a.href = url; a.download = fname;
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
          }
        } catch (e) {
          console.error(e);
          alert('Save failed: ' + (e?.message || e));
        }
      };

      // Hide Ink/Text buttons if the editor isn’t in your build
      async function detectAndToggleEditorButtons(app){
        try {
          const hasUI = !!app?.pdfViewer?.annotationEditorUIManager;
          const dom = frame.contentDocument;
          const hasInkId  = !!dom?.getElementById('editorInk');
          const hasTextId = !!dom?.getElementById('editorFreeText');

          if (!hasUI && !hasInkId)  document.getElementById('tsInk').style.display  = 'none';
          if (!hasUI && !hasTextId) document.getElementById('tsText').style.display = 'none';
        } catch {}
      }

      // Run detection once the embedded viewer initializes (covers initial load without file)
      waitForApp().then(detectAndToggleEditorButtons);
    })();
  </script>
</body>
</html>
