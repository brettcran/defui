<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Lock outer-page zoom; let PDF.js handle zoom internally -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>TurboSign</title>
  <style>
    :root { color-scheme: dark light; }
    html,body{
      margin:0; height:100%; background:#0b0c10;
      overscroll-behavior: contain;
      touch-action: manipulation; /* no double-tap zoom */
    }
    #viewer{ border:0; width:100%; height:100dvh; display:block; background:#121418; }

    /* Phones (≤768px) bottom toolbar */
    @media (max-width:768px){
      .ts-bar{
        position:fixed; left:0; right:0; bottom:0; z-index:9999;
        display:flex; gap:10px; align-items:center; justify-content:space-between;
        padding:10px 12px calc(10px + env(safe-area-inset-bottom));
        background:rgba(15,17,21,.92); backdrop-filter:saturate(1.2) blur(6px);
        border-top:1px solid #20242c; font:14px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      }
      .ts-btn{ flex:1 1 auto; min-height:48px; min-width:44px; display:flex; flex-direction:column; gap:6px;
               align-items:center; justify-content:center; padding:8px 6px; border-radius:10px;
               border:1px solid #2a2f39; color:#e8eaed; background:#1a1d24; }
      .ts-btn:active{ transform:translateY(1px); }
      .ts-btn svg{ width:22px; height:22px }
      .ts-file{ display:none }
      body{ padding-bottom: calc(76px + env(safe-area-inset-bottom)); }
    }

    /* Fallback Text */
    .ts-text{ position:absolute; left:0; top:0; min-width:80px; min-height:24px; white-space:pre-wrap;
      font:16px/1.25 -apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif; color:#111; background:transparent;
      outline:2px solid #4da3ff; outline-offset:2px; user-select:text; }
    .ts-text-handle{ position:absolute; right:-10px; bottom:-10px; width:18px; height:18px; border-radius:50%; background:#4da3ff; }

    /* Fallback Ink canvas */
    .ts-ink{ position:absolute; inset:0; pointer-events:auto; touch-action:none; } /* prevents page scroll while drawing */
  </style>
</head>
<body>
  <iframe id="viewer" src="/web/viewer.html#zoom=page-width" allow="clipboard-read; clipboard-write"></iframe>

  <!-- Phone toolbar -->
  <div class="ts-bar" id="tsBar" aria-label="TurboSign mobile toolbar">
    <button class="ts-btn" id="tsOpen" title="Open">
      <svg viewBox="0 0 24 24" fill="none"><path d="M3 7h5l2 2h11v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M3 7V5a2 2 0 0 1 2-2h4l2 2h6" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Open</span>
    </button>
    <button class="ts-btn" id="tsFind" title="Find">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="6.5" stroke="currentColor" stroke-width="1.6"/><path d="M20 20l-3.5-3.5" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Find</span>
    </button>
    <button class="ts-btn" id="tsZoomOut" title="Zoom out">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="7.5" stroke="currentColor" stroke-width="1.6"/><path d="M8 11h6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/><path d="M20 20l-3-3" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>−</span>
    </button>
    <button class="ts-btn" id="tsZoomIn" title="Zoom in">
      <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="7.5" stroke="currentColor" stroke-width="1.6"/><path d="M11 8v6M8 11h6" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>+</span>
    </button>
    <button class="ts-btn" id="tsInk" title="Ink">
      <svg viewBox="0 0 24 24" fill="none"><path d="M3 21l6-2 9.5-9.5a2.1 2.1 0 0 0-3-3L6 16l-3 5z" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Ink</span>
    </button>
    <button class="ts-btn" id="tsText" title="Text">
      <svg viewBox="0 0 24 24" fill="none"><path d="M4 6h16M12 6v12M7 18h10" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      <span>Text</span>
    </button>
    <button class="ts-btn" id="tsSave" title="Save">
      <svg viewBox="0 0 24 24" fill="none"><path d="M5 7h9l5 5v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M8 7V4h6v3" stroke="currentColor" stroke-width="1.6"/></svg>
      <span>Save</span>
    </button>
    <input id="tsFile" class="ts-file" type="file" accept="application/pdf" />
  </div>

  <script>
    /* ===== Global Safari zoom blockers (outer page) ===== */
    ['gesturestart','gesturechange','gestureend','dblclick'].forEach(t=>{
      addEventListener(t, e => e.preventDefault(), { passive:false });
    });
    // Classic double-tap blocker
    (function(){ let last=0; addEventListener('touchend',e=>{const now=Date.now(); if(now-last<300){ e.preventDefault(); } last=now; },{passive:false}); })();

    // Optional SW
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('/sw.js').catch(console.error);

    // iOS dynamic viewport
    const viewerEl = document.getElementById('viewer');
    const fitDvh = () => { viewerEl.style.height = Math.max(window.innerHeight, screen.height*0.6) + 'px'; };
    addEventListener('orientationchange', fitDvh, {passive:true});
    addEventListener('resize', fitDvh, {passive:true});
    fitDvh();

    (function(){
      const frame = document.getElementById('viewer');
      let lastObjectURL = null;

      const inkCanvases = new Map(); // page -> {canvas,ctx,dpr,dirty}
      const textBoxes   = new Set(); // DOM nodes for fallback text

      function waitForApp(){
        return new Promise(resolve=>{
          const poll=()=>{ try{
            const a = frame.contentWindow?.PDFViewerApplication;
            if (a?.initializedPromise) return a.initializedPromise.then(()=>resolve(a));
          }catch{} setTimeout(poll,50); };
          poll();
        });
      }

      // Inject blockers into the VIEWER (inside iframe) so Safari can’t zoom there either
      async function hardenViewerGestures(){
        const doc = frame.contentDocument; if (!doc) return;
        const s = doc.createElement('script');
        s.textContent = `
          ['gesturestart','gesturechange','gestureend','dblclick'].forEach(t=>{
            addEventListener(t, e => e.preventDefault(), { passive:false });
          });
          // double-tap blocker inside viewer
          (function(){ let last=0; addEventListener('touchend',e=>{const now=Date.now(); if(now-last<300){ e.preventDefault(); } last=now; },{passive:false}); })();
          // make main containers non-zoomable/pinch friendly
          try{ document.documentElement.style.touchAction='manipulation';
               document.body.style.touchAction='manipulation'; }catch{}
        `;
        doc.head.appendChild(s);
      }

      function clickInViewer(id){ try{
        const el = frame.contentDocument?.getElementById(id); if (el){ el.click(); return true; }
      }catch{} return false; }

      async function ensurePdfLib(){
        if (window.PDFLib) return true;
        // try local first; then CDN
        const trySrc = src => new Promise(res=>{ const sc=document.createElement('script'); sc.src=src;
          sc.onload=()=>res(true); sc.onerror=()=>res(false); document.body.appendChild(sc); });
        if (await trySrc('/vendor/pdf-lib.min.js')) return true;
        return await trySrc('https://unpkg.com/pdf-lib/dist/pdf-lib.min.js');
      }

      // OPEN local file
      document.getElementById('tsOpen').onclick = ()=> document.getElementById('tsFile').click();
      document.getElementById('tsFile').onchange = (e)=>{
        const f = e.target.files?.[0]; if (!f) return;
        if (lastObjectURL) { URL.revokeObjectURL(lastObjectURL); lastObjectURL = null; }
        lastObjectURL = URL.createObjectURL(f);
        frame.src = `/web/viewer.html?file=${encodeURIComponent(lastObjectURL)}#zoom=page-width`;
        waitForApp().then(app => {
          app.initializedPromise?.then(()=>hardenViewerGestures());
          app.eventBus?.on?.('documentloaded', ()=>{
            if (lastObjectURL) { URL.revokeObjectURL(lastObjectURL); lastObjectURL = null; }
            detectEditors(app); // hide Ink/Text buttons if native editor missing
            setupPageHooks(app); // attach fallback overlays to all pages
          });
        });
      };

      // FIND
      document.getElementById('tsFind').onclick = async ()=>{
        const app = await waitForApp();
        try { app.findBar?.open?.(); } catch {}
        frame.contentDocument?.getElementById('findInput')?.focus();
      };

      // ZOOM
      document.getElementById('tsZoomOut').onclick = async ()=>{
        const app = await waitForApp(); const v = app.pdfViewer;
        v.currentScale = +Math.max(0.1, v.currentScale / 1.1).toFixed(3);
      };
      document.getElementById('tsZoomIn').onclick = async ()=>{
        const app = await waitForApp(); const v = app.pdfViewer;
        v.currentScale = +Math.min(5, v.currentScale * 1.1).toFixed(3);
      };

      // INK (native if present, else fallback)
      document.getElementById('tsInk').onclick = async ()=>{
        const app = await waitForApp();
        if (clickInViewer('editorInk')) return;
        if (app?.pdfViewer?.annotationEditorUIManager?.updateMode) {
          app.pdfViewer.annotationEditorUIManager.updateMode('ink'); return;
        }
        enableInkFallback(app);
      };

      // TEXT (native if present, else fallback)
      document.getElementById('tsText').onclick = async ()=>{
        const app = await waitForApp();
        if (clickInViewer('editorFreeText')) return;
        if (app?.pdfViewer?.annotationEditorUIManager?.updateMode) {
          app.pdfViewer.annotationEditorUIManager.updateMode('freetext'); return;
        }
        enableTextFallback(app);
      };

      // SAVE (always works; flattens fallback Ink/Text)
      document.getElementById('tsSave').onclick = async ()=>{
        const app = await waitForApp();
        if (!app?.pdfDocument) { alert('Open a PDF first.'); return; }
        if (!await ensurePdfLib()) { alert('Save failed: pdf-lib unavailable.'); return; }

        const raw = await app.pdfDocument.getData();
        const pdfDoc = await window.PDFLib.PDFDocument.load(raw);

        // Ink flatten
        for (const [pageNum, obj] of inkCanvases){
          if (!obj?.dirty) continue;
          const pv = app.pdfViewer.getPageView(pageNum-1);
          const vp = pv.viewport;
          const dpr = obj.dpr || devicePixelRatio || 1;
          const widthPts  = obj.canvas.width  / dpr / vp.scale;
          const heightPts = obj.canvas.height / dpr / vp.scale;
          const png = await pdfDoc.embedPng(obj.canvas.toDataURL('image/png'));
          const page = pdfDoc.getPage(pageNum-1);
          page.drawImage(png, { x: 0, y: 0, width: widthPts, height: heightPts });
        }

        // Text flatten
        for (const box of textBoxes){
          if (!box.isConnected) continue;
          const pageDiv = box.closest('.page'); if (!pageDiv) continue;
          const pageNum = +pageDiv.getAttribute('data-page-number');
          const pv = app.pdfViewer.getPageView(pageNum-1);
          const vp = pv.viewport;
          const pr = pageDiv.getBoundingClientRect();
          const br = box.getBoundingClientRect();
          const leftPx = br.left - pr.left, topPx = br.top - pr.top;
          const widthPx = br.width, heightPx = br.height;
          const widthPts  = widthPx / vp.scale;
          const heightPts = heightPx / vp.scale;
          const xPts = leftPx / vp.scale;
          const yPts = vp.height - ((topPx + heightPts) / vp.scale);
          const page = pdfDoc.getPage(pageNum-1);
          const text = box.textContent || '';
          page.drawText(text, {
            x: xPts, y: yPts + 4,
            size: Math.max(8, Math.min(24, 12 / vp.scale)),
            color: window.PDFLib.rgb(0,0,0),
            maxWidth: widthPts, lineHeight: 1.25
          });
        }

        const out = await pdfDoc.save();
        const blob = new Blob([out], { type:'application/pdf' });
        const appName = (app._docFilename || app.baseUrl || 'document.pdf').toString();
        const fname = appName.split('/').pop().split('#')[0].split('?')[0] || 'document.pdf';
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const url = URL.createObjectURL(blob);
        if (isIOS) { window.open(url, '_blank'); setTimeout(()=>URL.revokeObjectURL(url), 15000); }
        else { const a=document.createElement('a'); a.href=url; a.download=fname; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }
      };

      /* ---------- Fallback systems ---------- */

      // Attach per-page hooks so overlays always size/realign with zoom/rerender
      function setupPageHooks(app){
        const doc = frame.contentDocument; if (!doc) return;
        const container = doc.getElementById('viewer'); if (!container) return;

        // Ensure canvases/text stay sized to the page on zoom or render
        app.eventBus?.on?.('pagerendered', ({pageNumber})=>{
          const pageDiv = container.querySelector(`.page[data-page-number="${pageNumber}"]`);
          if (!pageDiv) return;
          const r = pageDiv.getBoundingClientRect();
          const entry = inkCanvases.get(pageNumber);
          if (entry){
            const { canvas, dpr } = entry;
            canvas.width = Math.round(r.width * dpr);
            canvas.height= Math.round(r.height * dpr);
            canvas.style.width = r.width+'px';
            canvas.style.height= r.height+'px';
          }
        });
        app.eventBus?.on?.('scalechanging', ()=>{
          // trigger rerender takes care of size via 'pagerendered'
        });
      }

      function detectEditors(app){
        try {
          const hasUI = !!app?.pdfViewer?.annotationEditorUIManager;
          const dom = frame.contentDocument;
          const hasInkId  = !!dom?.getElementById('editorInk');
          const hasTextId = !!dom?.getElementById('editorFreeText');
          if (!hasUI && !hasInkId)  document.getElementById('tsInk').style.display  = 'none';
          if (!hasUI && !hasTextId) document.getElementById('tsText').style.display = 'none';
        } catch {}
      }

      function enableInkFallback(app){
        const doc = frame.contentDocument; const container = doc.getElementById('viewer'); if (!container) return;
        const pages = Array.from(container.querySelectorAll('.page'));
        for (const pageDiv of pages){
          pageDiv.style.position='relative';
          const n = +pageDiv.getAttribute('data-page-number');
          if (inkCanvases.has(n)) continue;
          const c = doc.createElement('canvas'); c.className='ts-ink'; pageDiv.appendChild(c);
          const dpr = Math.max(devicePixelRatio||1, 1);
          const r = pageDiv.getBoundingClientRect();
          c.width = Math.round(r.width*dpr); c.height=Math.round(r.height*dpr);
          c.style.width=r.width+'px'; c.style.height=r.height+'px';
          const ctx = c.getContext('2d'); ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#111'; ctx.lineWidth=2.5*dpr;
          inkCanvases.set(n,{canvas:c,ctx,dpr,dirty:false});

          let drawing=false,lx=0,ly=0;
          c.addEventListener('pointerdown', e=>{ drawing=true; c.setPointerCapture(e.pointerId);
            const b=c.getBoundingClientRect(); lx=(e.clientX-b.left)*dpr; ly=(e.clientY-b.top)*dpr; e.preventDefault();
          },{passive:false});
          c.addEventListener('pointermove', e=>{ if(!drawing) return; const b=c.getBoundingClientRect();
            const x=(e.clientX-b.left)*dpr, y=(e.clientY-b.top)*dpr; ctx.beginPath(); ctx.moveTo(lx,ly); ctx.lineTo(x,y); ctx.stroke(); lx=x; ly=y; inkCanvases.get(n).dirty=true;
          });
          c.addEventListener('pointerup', e=>{ drawing=false; try{c.releasePointerCapture(e.pointerId);}catch{} });
          c.addEventListener('pointercancel', ()=>{ drawing=false; });
        }
        alert('Ink: draw on the page. (Using TurboSign fallback)');
      }

      function enableTextFallback(app){
        const doc = frame.contentDocument; const container = doc.getElementById('viewer'); if (!container) return;
        const onClick = (ev)=>{
          const pageDiv = ev.target.closest('.page'); if (!pageDiv) return;
          const rect = pageDiv.getBoundingClientRect();
          const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
          const box = doc.createElement('div'); box.className='ts-text'; box.contentEditable='true'; box.textContent='Type…';
          pageDiv.style.position='relative'; pageDiv.appendChild(box); textBoxes.add(box);
          box.style.left = Math.max(4, Math.min(x-40, rect.width-84))+'px';
          box.style.top  = Math.max(4, Math.min(y-12, rect.height-24))+'px';
          box.focus();

          // drag
          let dragging=false,sx=0,sy=0,bl=0,bt=0;
          box.addEventListener('pointerdown',(e)=>{ if(e.target===box){ dragging=true; box.setPointerCapture(e.pointerId); sx=e.clientX; sy=e.clientY; bl=parseFloat(box.style.left)||0; bt=parseFloat(box.style.top)||0; e.preventDefault(); } },{passive:false});
          box.addEventListener('pointermove',(e)=>{ if(!dragging) return; const dx=e.clientX-sx, dy=e.clientY-sy; let L=bl+dx, T=bt+dy;
            const pr=pageDiv.getBoundingClientRect(); const br=box.getBoundingClientRect();
            L=Math.max(0,Math.min(L, pr.width-br.width)); T=Math.max(0,Math.min(T, pr.height-br.height));
            box.style.left=L+'px'; box.style.top=T+'px';
          });
          box.addEventListener('pointerup',(e)=>{ dragging=false; try{box.releasePointerCapture(e.pointerId);}catch{} });

          // resize
          const handle=doc.createElement('div'); handle.className='ts-text-handle'; box.appendChild(handle);
          let resizing=false,rsx=0,rsy=0,bw=0,bh=0;
          handle.addEventListener('pointerdown',(e)=>{ e.stopPropagation(); resizing=true; handle.setPointerCapture(e.pointerId); rsx=e.clientX; rsy=e.clientY; bw=box.offsetWidth; bh=box.offsetHeight; });
          handle.addEventListener('pointermove',(e)=>{ if(!resizing) return; const dx=e.clientX-rsx, dy=e.clientY-rsy; box.style.width=(bw+dx)+'px'; box.style.height=(bh+dy)+'px'; });
          handle.addEventListener('pointerup',(e)=>{ resizing=false; try{handle.releasePointerCapture(e.pointerId);}catch{} });

          // delete when empty
          box.addEventListener('keydown',(e)=>{ if((e.key==='Backspace'||e.key==='Delete') && box.textContent.trim()===''){ textBoxes.delete(box); box.remove(); } });

          container.removeEventListener('click', onClick, true);
        };
        container.addEventListener('click', onClick, true);
        alert('Text: tap a page to place. Drag to move, resize with the dot, backspace to remove. (Fallback)');
      }

      // Initial hardening for built-in viewer (when it first loads even w/o a file)
      waitForApp().then(()=>hardenViewerGestures());
    })();
  </script>
</body>
</html>